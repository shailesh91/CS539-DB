import java.io.IOException;
import java.io.StringReader;

import org.apache.hadoop.conf.Configuration;
import org.apache.hadoop.conf.Configured;
import org.apache.hadoop.fs.FileSystem;
import org.apache.hadoop.fs.Path;
import org.apache.hadoop.io.LongWritable;
import org.apache.hadoop.io.Text;
import org.apache.hadoop.mapreduce.Job;
import org.apache.hadoop.mapreduce.Mapper;
import org.apache.hadoop.mapreduce.Reducer;
import org.apache.hadoop.mapreduce.lib.input.FileInputFormat;
import org.apache.hadoop.mapreduce.lib.input.KeyValueTextInputFormat;
import org.apache.hadoop.mapreduce.lib.input.TextInputFormat;
import org.apache.hadoop.mapreduce.lib.output.TextOutputFormat;
import org.apache.hadoop.mapreduce.lib.reduce.LongSumReducer;
import org.apache.hadoop.util.Tool;
import org.apache.hadoop.util.ToolRunner;

import chesspresso.game.Game;
import chesspresso.pgn.PGNReader;

/** Caculate the percentage of every word. */
public class ChessGameB extends Configured implements Tool {
	private static final String OUTPUT_PATH = "intermediate_output/chessgameB";
	public static class MyMapper extends Mapper<LongWritable, Text, Text, LongWritable> {
    private static final transient LongWritable one = new LongWritable(1);
    
    /** mapper(). */
    @Override
    public void map(final LongWritable key, final Text value, final Context context)
        throws IOException, InterruptedException {
    	String line = value.toString().replace("\n\n[Event ","");
    	
		line = "[Event " + line;
    	StringReader sreader = new StringReader(line);
    	try{
			PGNReader parser = new PGNReader(sreader, "parse");
			Game game = parser.parseGame();
			if(!game.toString().contains("null")){
				String B = game.getBlack();
				String W = game.getWhite();
				int R = game.getResult();
				if(R==2){
					context.write(new Text(B+"-B-W"), one);
					context.write(new Text(W+"-W-L"), one);
				}else if(R==1){
					context.write(new Text(W+"-W-D"), one);
					context.write(new Text(B+"-B-D"), one);
				}else if(R==0){
					context.write(new Text(W+"-W-W"), one);
					context.write(new Text(B+"-B-L"), one);
				}
			}
		}catch(Exception ee){
			System.out.println(ee);
		}
    }
  }


  /** Reducer. */
  public static class MyReducer extends Reducer<Text, LongWritable, Text, LongWritable> {
    /** Implement reduce(). */
	@Override
    public void reduce(final Text key, final Iterable<LongWritable> values, final Context context)
        throws IOException, InterruptedException {
      int sum = 0;
      for (LongWritable val : values) {
        sum += Integer.parseInt(val.toString());
      }
      context.write(key,new LongWritable(sum));
    }
  }
  
  public static class MyMapper2 extends Mapper<Text, Text, Text, Text> {
	  /** mapper(). */
	  @Override
	  public void map(final Text key, final Text value, final Context context)
	        throws IOException, InterruptedException {
		  String[] keyArray = key.toString().split("-");
		  String x = keyArray[1]+"-"+keyArray[2]+"-"+value.toString();
		  context.write(new Text(keyArray[0]), new Text(x));
	  }
  }
  
  /** Reducer. */
  public static class MyReducer2 extends Reducer<Text, Text, Text, Text> {
    /** Implement reduce(). */
	@Override
    public void reduce(final Text key, final Iterable<Text> values, final Context context)
        throws IOException, InterruptedException {
		int bw=0,bl=0,bd=0,ww=0,wl=0,wd=0,wSum=0,bSum=0;
		for (Text val : values) {
		  String v= val.toString();
    	  String[] s = v.split("-");
    	  int num = Integer.parseInt(s[2]);
    	  if(s[0].equals("B")){
    		  bSum+=num;
    		  if(s[1].equals("W")){
    			bw +=  num;
      		  }else if(s[1].equals("L")){
      			bl += num;
      		  }else if(s[1].equals("D")){
      			bd += num;
      		  }
    	  }else if(s[0].equals("W")){
    		  wSum+=num;
    		  if(s[1].equals("W")){
    			ww +=  num;
    		  }else if(s[1].equals("L")){
    			wl += num;
    		  }else if(s[1].equals("D")){
    			wd += num;
    		  }
    	  }
    	}
		
		if(wSum != 0){
			float wwf= (float)ww/wSum;
			float wlf= (float)wl/wSum;
			float wdf= (float)wd/wSum;
			context.write(key, new Text("White "+wwf+" "+wlf+" "+wdf));
		}
		if(bSum != 0){
			float bwf= (float)bw/bSum;
			float blf= (float)bl/bSum;
			float bdf= (float)bd/bSum;
			context.write(key, new Text("Black "+bwf+" "+blf+" "+bdf));
		}
    }
  }

  /**
   * Implement run().
   */
  @Override
  public int run(final String[] args) throws Exception {
    final Path input = new Path(args[0]);
    final Path output = new Path(args[1]);

    final Configuration conf = this.getConf();
    Path outputDir = new Path(args[1]);
    FileSystem fs = FileSystem.get(conf);
    fs.delete(outputDir, true);
    fs.delete(new Path(OUTPUT_PATH), true);
    
    final Job job = Job.getInstance(conf, "Chess Game B: " + input + "->" + output);
    job.setJarByClass(ChessGameB.class);

    job.setMapperClass(MyMapper.class);
    job.setCombinerClass(LongSumReducer.class);
    job.setReducerClass(MyReducer.class);
    
    job.setOutputKeyClass(Text.class);
    job.setOutputValueClass(LongWritable.class);

    //job.setInputFormatClass(TextInputFormat.class);
    job.setInputFormatClass(PGNInputFormat.class);
    job.setOutputFormatClass(TextOutputFormat.class);
    
    FileInputFormat.addInputPath(job, input);
    FileInputFormat.setInputDirRecursive(job, true);
    
    TextOutputFormat.setOutputPath(job, new Path(OUTPUT_PATH));

    job.waitForCompletion(true);
    
    final Job job2 = Job.getInstance(conf, "ChessGameB: " + input + "->" + output);
    
    job2.setJarByClass(ChessGameB.class);

    job2.setMapperClass(MyMapper2.class);
    job2.setReducerClass(MyReducer2.class);
    //job2.setNumReduceTasks(1);

    job2.setOutputKeyClass(Text.class);
    job2.setOutputValueClass(Text.class);

    job2.setInputFormatClass(KeyValueTextInputFormat.class);
    job2.setOutputFormatClass(TextOutputFormat.class);

    TextInputFormat.addInputPath(job2, new Path(OUTPUT_PATH));
    FileInputFormat.setInputDirRecursive(job2, true);
    TextOutputFormat.setOutputPath(job2, new Path(args[1]));

    return job2.waitForCompletion(true) ? 0 : 1;
    
  }

  /**
   * main.
   */
  public static void main(final String[] args) throws Exception {
    final int returnCode = ToolRunner.run(new Configuration(), new ChessGameB(), args);
    System.exit(returnCode);
  }
}