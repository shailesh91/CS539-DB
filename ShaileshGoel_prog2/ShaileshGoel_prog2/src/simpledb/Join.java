package simpledb;
import java.util.*;

import com.sun.org.apache.xml.internal.security.utils.DigesterOutputStream;

import java.io.*;

/**
 * The Join operator implements the relational join operation.
 */
public class Join extends AbstractDbIterator {

    private JoinPredicate _predicate;
    private DbIterator _outerRelation;
    private DbIterator _innerRelation;
    private Iterator<Tuple> _outerPage = null;
    private Iterator<Tuple> _innerPage = null;

    private Tuple _outerRecent = null;
    private Tuple _innerRecent = null;

    //For PNL    
    private HeapFileIterator _outerHeapFile = null;
    private Page _outerHeapFilePage = null;
    private boolean rewindInnerRelationFlag = true;
    private boolean isOuterTupleInSamePage = false;
    
    //For SMJ
    private boolean borderFlag = false;
    private boolean pendingFlag = false;
    private List<Tuple> _listTuplesTemp;
    
    private int _joinType = 0;
    private int _numMatches = 0;
    private int _numComp = 0;
  
    public static final int SNL = 0;
    public static final int PNL = 1;    
    public static final int BNL = 2;    
    public static final int SMJ = 3;    
    public static final int HJ = 4;    
    /**
     * Constructor.  Accepts to children to join and the predicate
     * to join them on
     *
     * @param p The predicate to use to join the children
     * @param child1 Iterator for the left(outer) relation to join
     * @param child2 Iterator for the right(inner) relation to join
     */
    public Join(JoinPredicate p, DbIterator child1, DbIterator child2) {
        //IMPLEMENT THIS
        _predicate = p;
        _outerRelation = child1;
        _innerRelation = child2;
        _listTuplesTemp = new ArrayList<Tuple>();
    }

    public void setJoinAlgorithm(int joinAlgo){
        _joinType = joinAlgo;
    }
    /**
     * @see simpledb.TupleDesc#combine(TupleDesc, TupleDesc) for possible implementation logic.
     */
    public TupleDesc getTupleDesc() {
	//IMPLEMENT THIS
        return TupleDesc.combine(_outerRelation.getTupleDesc(),_innerRelation.getTupleDesc());
    }

    public void open()
        throws DbException, NoSuchElementException, TransactionAbortedException, IOException {
		//IMPLEMENT THIS
            _outerRelation.open();
            _innerRelation.open();

    }

    public void close() {
        //IMPLEMENT THIS
        _outerRelation.close();
        _innerRelation.close();
        _outerRecent = null;
        _innerRecent = null;
    }

    public void rewind() throws DbException, TransactionAbortedException, IOException {
        //IMPLEMENT THIS
        _outerRelation.rewind();
        _innerRelation.rewind();
        _outerRecent = null;
        _innerRecent = null;
    }

    /**
     * Returns the next tuple generated by the join, or null if there are no more tuples.
     * Logically, this is the next tuple in r1 cross r2 that satisfies the join
     * predicate.  There are many possible implementations; the simplest is a
     * nested loops join.
     * <p>
     * Note that the tuples returned from this particular implementation of
     * Join are simply the concatenation of joining tuples from the left and
     * right relation. Therefore, there will be two copies of the join attribute
     * in the results.  (Removing such duplicate columns can be done with an
     * additional projection operator if needed.)
     * <p>
     * For example, if one tuple is {1,2,3} and the other tuple is {1,5,6},
     * joined on equality of the first column, then this returns {1,2,3,1,5,6}.
     *
     * @return The next matching tuple.
     * @see JoinPredicate#filter
     */
    protected Tuple readNext() throws TransactionAbortedException, DbException {
        switch(_joinType){
            case SNL: return SNL_readNext();
            case PNL: return PNL_readNext();
            case BNL: return BNL_readNext();
            case SMJ: return SMJ_readNext();
            case HJ: return HJ_readNext();
            default: return SNL_readNext();
        }
    }

    protected Tuple SNL_readNext() throws TransactionAbortedException, DbException {
        try{
            _innerRecent = null;
            //iterate over outer relation
            while (_outerRecent != null || _outerRelation.hasNext()) {
            	//move to next outer tuple
                if (_outerRecent == null) _outerRecent = _outerRelation.next();
                //iterate over inner relation
                while (_innerRelation.hasNext()) {
                    _innerRecent = _innerRelation.next();
                    if (_predicate.filter(_outerRecent, _innerRecent)){
                        _numMatches++;
                        //return new joined tuple
                        return joinTuple(_outerRecent, _innerRecent, getTupleDesc()); // join to make a new tuple
                    }
                }
                //finished with iteration over inner relation for a outer tuple, reset the inner realtion
                if(_outerRelation.hasNext()) _innerRelation.rewind();
                _outerRecent = null;
            }
        }catch(Exception e){
            e.printStackTrace();
        }
    	return null;
    }


    protected Tuple PNL_readNext() throws TransactionAbortedException, DbException {
        //IMPLEMENT THIS (EXTRA CREDIT ONLY)
    	while(true){
    		//open file for the outer relation
	    	if(_outerHeapFile == null) _outerHeapFile = (HeapFileIterator) ((SeqScan)_outerRelation)._iterator;
	    	try{
	    		if (!isOuterTupleInSamePage){
	    			if(_outerHeapFile.hasNext()){
	    				//get outer relation's page
	    				_outerHeapFilePage = _outerHeapFile.getCurrentPage();
	    				_outerPage = new HeapPageIterator((HeapPage)_outerHeapFilePage);
	    				//iterate to set the pointer to the tuple next to the present page last tuple for the next iteration over inner relation tuples
						while(_outerHeapFile.getCurrentPage().id().pageno() == _outerHeapFilePage.id().pageno() && _outerHeapFile.hasNext()) 
							_outerHeapFile.next();
						if (!rewindInnerRelationFlag) _innerRelation.rewind();
						rewindInnerRelationFlag = false;
						isOuterTupleInSamePage = true;
	    			}else
	    				return null;
	    		}
	    		//iterate over each tuple of the inner relation for each of the outer relation's page.
	    		_outerRecent = null;
	    		while (_innerRecent != null || _innerRelation.hasNext()) {
	                if (_innerRecent == null) _innerRecent = _innerRelation.next();
	                while (_outerPage.hasNext()) {
	                	_outerRecent = _outerPage.next();
	                	if (_predicate.filter(_outerRecent, _innerRecent)){
	                		_numMatches++;
	                        return joinTuple(_outerRecent, _innerRecent, getTupleDesc()); // join to make a new tuple
	                	}
	                }
	                if(_innerRelation.hasNext()) ((HeapPageIterator)_outerPage).rewind();
	                _innerRecent = null;
	            }
				isOuterTupleInSamePage = false;
		        continue;
    		}catch(Exception e){
        		e.printStackTrace();
        	}
	    	return null;
    	}
    }

	protected Tuple BNL_readNext() throws TransactionAbortedException, DbException {
        //no need to implement this
        return null;
    }
	
	protected Tuple SMJ_readNext() throws TransactionAbortedException, DbException {
        //IMPLEMENT THIS. YOU CAN ASSUME THE JOIN PREDICATE IS ALWAYS =
        //Files already sorted on same index (Test Case).
			//Tuples generated from the previous iteration in case of multiple matches.
			if(pendingFlag){
				for (Iterator<Tuple> it = _listTuplesTemp.iterator(); it.hasNext();) {
					Tuple t = it.next();
					it.remove();
					return t;
				}
				pendingFlag = false;
			}
			
			if(borderFlag) return null;
			try{
				if(_outerRecent == null)
	            	_outerRecent = _outerRelation.next();
	            
	    		if (_innerRecent == null) {
	            	_innerRecent = _innerRelation.next();
	            }
				while(_outerRelation.hasNext() && _innerRelation.hasNext() ||
	            		(!_outerRelation.hasNext()
	            				&&!_innerRelation.hasNext()&&_predicate.filter(_outerRecent, _innerRecent)) ||
	            		(_outerRelation.hasNext()
	            				&&!_innerRelation.hasNext()
	            				&&_predicate.getLeftField(_outerRecent).compare(Predicate.Op.LESS_THAN_OR_EQ, _predicate.getRightField(_innerRecent))) ||
	            		(_innerRelation.hasNext()
	            				&&!_outerRelation.hasNext()
	            				&&_predicate.getLeftField(_outerRecent).compare(Predicate.Op.GREATER_THAN_OR_EQ, _predicate.getRightField(_innerRecent)))){
					if (_predicate.filter(_outerRecent, _innerRecent)){
						List<Tuple> listSameInnerTemp = new ArrayList<Tuple>();
	            	    List<Tuple> listSameOuterTemp = new ArrayList<Tuple>();
	            	    Tuple _tempTuple = null;
	            	    listSameInnerTemp.add(_innerRecent);
	            	    listSameOuterTemp.add(_outerRecent);
	            	    
	            	    Field fi = _predicate.getRightField(_innerRecent);
	            		while(_innerRelation.hasNext()){
	            			_innerRecent = _innerRelation.next();
	            			if(fi.compare(Predicate.Op.EQUALS,_predicate.getRightField(_innerRecent))){
	            				listSameInnerTemp.add(_innerRecent);
	            			}else{
	            				break;
	            			}
	            		}
	            		Field fo = _predicate.getLeftField(_outerRecent);
	            		while(_outerRelation.hasNext()){
	            			_outerRecent = _outerRelation.next();
	            			if(fo.compare(Predicate.Op.EQUALS, _predicate.getLeftField(_outerRecent))){
	            				listSameOuterTemp.add(_outerRecent);
	            			}else{
	            				break;
	            			}
	            		}
	            		
	            	    if(!_innerRelation.hasNext() && !_outerRelation.hasNext()) borderFlag = true;
	            		
	            		if(listSameInnerTemp.size() == 1 && listSameOuterTemp.size() == 1){	            			
	            			_tempTuple = joinTuple(listSameOuterTemp.get(0), listSameInnerTemp.get(0), getTupleDesc());
	            			listSameInnerTemp.clear();
	            			listSameOuterTemp.clear();
	            			_numMatches++;
	            			return _tempTuple;
	            		}else{
	            			boolean lFlag= false;
	            			pendingFlag = true;
	            			for (Iterator<Tuple> itO = listSameOuterTemp.iterator(); itO.hasNext();) {
	            				Tuple oTemp = itO.next();
	            				for (Iterator<Tuple> itI = listSameInnerTemp.iterator(); itI.hasNext();) {
	            					Tuple iTemp = itI.next();
	            					_numMatches++;
	            					if(lFlag){
	            						_listTuplesTemp.add(joinTuple(oTemp, iTemp, getTupleDesc()));
	            					}else{
	            						_tempTuple = joinTuple(oTemp, iTemp, getTupleDesc());
	            						lFlag = true;
	            					}
	            				}
	            			}
	            			return _tempTuple;
	            		}
					}else if (_predicate.getLeftField(_outerRecent).compare(Predicate.Op.LESS_THAN, _predicate.getRightField(_innerRecent))){
						if(_outerRelation.hasNext())
							_outerRecent = _outerRelation.next();
						else
							continue;
	                }else if(_predicate.getLeftField(_outerRecent).compare(Predicate.Op.GREATER_THAN, _predicate.getRightField(_innerRecent))){
	                	if(_innerRelation.hasNext())	
	                		_innerRecent = _innerRelation.next();
	                	else
	                		continue;
	                }
	            }	
			}catch(Exception e){
				e.printStackTrace();
			}
        return null;
    }
    
    protected Tuple HJ_readNext() throws TransactionAbortedException, DbException {
        //no need to implement this
        return null;
    }


    private Tuple joinTuple(Tuple outer, Tuple inner, TupleDesc tupledesc){
    	Tuple nt = new Tuple(tupledesc);
        int numFieldsOuter = outer.getTupleDesc().numFields();
        
        for (int i = 0; i < numFieldsOuter; i++)
            nt.setField(i, outer.getField(i));
        for (int i = 0; i < inner.getTupleDesc().numFields(); i++)
            nt.setField(i + numFieldsOuter, inner.getField(i));
        
        return nt;
    }

    public int getNumMatches(){
        return _numMatches;
    }
    public int getNumComp(){
        return _numComp;
    }
}
